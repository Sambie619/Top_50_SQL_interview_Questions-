1)Not Boring Movies

Write a solution to report the movies with an odd-numbered ID and a description that is not "boring".
Return the result table ordered by rating in descending order.
The result format is in the following example.

Example 1:
Input: 
Cinema table:
+----+------------+-------------+--------+
| id | movie      | description | rating |
+----+------------+-------------+--------+
| 1  | War        | great 3D    | 8.9    |
| 2  | Science    | fiction     | 8.5    |
| 3  | irish      | boring      | 6.2    |
| 4  | Ice song   | Fantacy     | 8.6    |
| 5  | House card | Interesting | 9.1    |
+----+------------+-------------+--------+
Output: 
+----+------------+-------------+--------+
| id | movie      | description | rating |
+----+------------+-------------+--------+
| 5  | House card | Interesting | 9.1    |
| 1  | War        | great 3D    | 8.9    |
+----+------------+-------------+--------+
Explanation: 
We have three movies with odd-numbered IDs: 1, 3, and 5. The movie with ID = 3 is boring so we do not include it in the answer.

Solution:
select * from cinema where id%2=1 and description <>'boring' order by rating desc;

Explanation:
id%2==1 filter out odd id's and '<>' is a not equal to operator the result is then ordered by rating in descending order

2)Average Selling Price

Write a solution to find the average selling price for each product. average_price should be rounded to 2 decimal places. If a product does
not have any sold units, its average selling price is assumed to be 0.Return the result table in any order.
The result format is in the following example.
Example 1:
Input: 
Prices table:
+------------+------------+------------+--------+
| product_id | start_date | end_date   | price  |
+------------+------------+------------+--------+
| 1          | 2019-02-17 | 2019-02-28 | 5      |
| 1          | 2019-03-01 | 2019-03-22 | 20     |
| 2          | 2019-02-01 | 2019-02-20 | 15     |
| 2          | 2019-02-21 | 2019-03-31 | 30     |
+------------+------------+------------+--------+
UnitsSold table:
+------------+---------------+-------+
| product_id | purchase_date | units |
+------------+---------------+-------+
| 1          | 2019-02-25    | 100   |
| 1          | 2019-03-01    | 15    |
| 2          | 2019-02-10    | 200   |
| 2          | 2019-03-22    | 30    |
+------------+---------------+-------+
Output: 
+------------+---------------+
| product_id | average_price |
+------------+---------------+
| 1          | 6.96          |
| 2          | 16.96         |
+------------+---------------+
Explanation: 
Average selling price = Total Price of Product / Number of products sold.
Average selling price for product 1 = ((100 * 5) + (15 * 20)) / 115 = 6.96
Average selling price for product 2 = ((200 * 15) + (30 * 30)) / 230 = 16.96

Solution:
select p.product_id,coalesce(round(sum(p.price*u.units)/sum(u.units),2),0)as average_price from prices p left join unitssold u on
p.product_id=u.product_id and u.purchase_date between p.start_date and p.end_date group by p.product_id;

Explanation:
This query calculates the average selling price for each product. It joins product price information with units sold data, ensuring sales are 
matched to the correct price period. The COALESCE function handles products with no sales, returning an average price of 0 in such cases. 

3)Project Employees I

Write an SQL query that reports the average experience years of all the employees for each project, rounded to 2 digits.
Return the result table in any order.
The query result format is in the following example.

Example 1:
Input: 
Project table:
+-------------+-------------+
| project_id  | employee_id |
+-------------+-------------+
| 1           | 1           |
| 1           | 2           |
| 1           | 3           |
| 2           | 1           |
| 2           | 4           |
+-------------+-------------+
Employee table:
+-------------+--------+------------------+
| employee_id | name   | experience_years |
+-------------+--------+------------------+
| 1           | Khaled | 3                |
| 2           | Ali    | 2                |
| 3           | John   | 1                |
| 4           | Doe    | 2                |
+-------------+--------+------------------+
Output: 
+-------------+---------------+
| project_id  | average_years |
+-------------+---------------+
| 1           | 2.00          |
| 2           | 2.50          |
+-------------+---------------+
Explanation: The average experience years for the first project is (3 + 2 + 1) / 3 = 2.00 and for the second project is (3 + 2) / 2 = 2.50

Solution:

select p.project_id,round(avg(e.experience_years),2)as average_years from project p join employees e on
p.employee_id=e.employee_id group by p.project_id;

Explanation:
This SQL query calculates the average experience years of employees for each project. It achieves this by joining the Project and
Employee tables on employee_id, then groups the results by project_id. Finally, it computes the average of experience_years for each project and rounds the result to two decimal places. 

4)Percentage of Users Attended a Contest

Write a solution to find the percentage of the users registered in each contest rounded to two decimals.
Return the result table ordered by percentage in descending order. In case of a tie, order it by contest_id in ascending order.
The result format is in the following example.

Example 1:
Input: 
Users table:
+---------+-----------+
| user_id | user_name |
+---------+-----------+
| 6       | Alice     |
| 2       | Bob       |
| 7       | Alex      |
+---------+-----------+
Register table:
+------------+---------+
| contest_id | user_id |
+------------+---------+
| 215        | 6       |
| 209        | 2       |
| 208        | 2       |
| 210        | 6       |
| 208        | 6       |
| 209        | 7       |
| 209        | 6       |
| 215        | 7       |
| 208        | 7       |
| 210        | 2       |
| 207        | 2       |
| 210        | 7       |
+------------+---------+
Output: 
+------------+------------+
| contest_id | percentage |
+------------+------------+
| 208        | 100.0      |
| 209        | 100.0      |
| 210        | 100.0      |
| 215        | 66.67      |
| 207        | 33.33      |
+------------+------------+
Explanation: 
All the users registered in contests 208, 209, and 210. The percentage is 100% and we sort them in the answer table by contest_id in ascending order.
Alice and Alex registered in contest 215 and the percentage is ((2/3) * 100) = 66.67%
Bob registered in contest 207 and the percentage is ((1/3) * 100) = 33.33%

Solution:

select contest_id,round(count(user_id)*100/(select count(user_id)from users),2)as percentage 
from register group by contest_id order by percentage desc,contest_id;

Explanation:
- It calculates the percentage of users registered for each contest by joining the `Users` and `Register` tables, grouping by `contest_id`, 
  and dividing the count of registered users by the total number of users.
- Results are sorted in descending order of registration percentage, and for ties, by ascending `contest_id`, giving a clear leaderboard of contest popularity.

5)Queries Quality and Percentage

We define query quality as:
The average of the ratio between query rating and its position.
We also define poor query percentage as:
The percentage of all queries with rating less than 3.
Write a solution to find each query_name, the quality and poor_query_percentage.
Both quality and poor_query_percentage should be rounded to 2 decimal places.
Return the result table in any order.
The result format is in the following example.

Example 1:

Input: 
Queries table:
+------------+-------------------+----------+--------+
| query_name | result            | position | rating |
+------------+-------------------+----------+--------+
| Dog        | Golden Retriever  | 1        | 5      |
| Dog        | German Shepherd   | 2        | 5      |
| Dog        | Mule              | 200      | 1      |
| Cat        | Shirazi           | 5        | 2      |
| Cat        | Siamese           | 3        | 3      |
| Cat        | Sphynx            | 7        | 4      |
+------------+-------------------+----------+--------+
Output: 
+------------+---------+-----------------------+
| query_name | quality | poor_query_percentage |
+------------+---------+-----------------------+
| Dog        | 2.50    | 33.33                 |
| Cat        | 0.66    | 33.33                 |
+------------+---------+-----------------------+
Explanation: 
Dog queries quality is ((5 / 1) + (5 / 2) + (1 / 200)) / 3 = 2.50
Dog queries poor_ query_percentage is (1 / 3) * 100 = 33.33

Cat queries quality equals ((2 / 5) + (3 / 3) + (4 / 7)) / 3 = 0.66
Cat queries poor_ query_percentage is (1 / 3) * 100 = 33.33

Solution:

select query_name,round(avg(rating/position),2)as quality,round(100*sum(case when rating < 3 tehn1 else 0 end)/count(rating),2)as poor_query_percentage from
queries group by query_name;

Explanation:
- Quality Score: For each `query_name`, it calculates the average of `rating ÷ position`, which gives a sense of how well-rated the query is relative to its position — then rounds it to two decimal places.
- Poor Query Percentage: It counts how many times the `rating` is less than 3, divides that by the total number of ratings for that query, and converts it into a percentage — showing how often the query is considered poor.
- Grouped Results: The query groups all this by `query_name`, so you get one row per query with its average quality and percentage of poor ratings.

6)Monthly Transactions I

Write an SQL query to find for each month and country, the number of transactions and their total amount, the number of approved transactions and their total amount.
Return the result table in any order.
The query result format is in the following example.
Example 1:
Input: 
Transactions table:
+------+---------+----------+--------+------------+
| id   | country | state    | amount | trans_date |
+------+---------+----------+--------+------------+
| 121  | US      | approved | 1000   | 2018-12-18 |
| 122  | US      | declined | 2000   | 2018-12-19 |
| 123  | US      | approved | 2000   | 2019-01-01 |
| 124  | DE      | approved | 2000   | 2019-01-07 |
+------+---------+----------+--------+------------+
Output: 
+----------+---------+-------------+----------------+--------------------+-----------------------+
| month    | country | trans_count | approved_count | trans_total_amount | approved_total_amount |
+----------+---------+-------------+----------------+--------------------+-----------------------+
| 2018-12  | US      | 2           | 1              | 3000               | 1000                  |
| 2019-01  | US      | 1           | 1              | 2000               | 2000                  |
| 2019-01  | DE      | 1           | 1              | 2000               | 2000                  |
+----------+---------+-------------+----------------+--------------------+-----------------------+

Solution:
select date_format(trans_date,'%Y-%m')as month,country,count(id)as trans_count,sum(case when state="approved"then 1 else 0 end)as approved_count,sum(amount)as trans_total_amount,sum(case when state="approved"then amount
else 0 end)as  approved_total_amount  from transactions group by country,month order by month;

Explanation:
- `date_format(trans_date,'%Y-%m')` → Extracts month from transaction date.
-  `group by country, month` → Groups data by country and month.
-  `count(id)` → Total transactions.
- `sum(case when state='approved' then 1 else 0)` → Approved transaction count.
-  `sum(amount)` → Total transaction amount.
-  `sum(case when state='approved' then amount else 0)` → Approved transaction amount.
-  `order by month` → Sorts results chronologically.

7)Immediate Food Delivery ||

If the customer's preferred delivery date is the same as the order date, then the order is called immediate; otherwise, it is called scheduled.
The first order of a customer is the order with the earliest order date that the customer made. It is guaranteed that a customer has precisely one first order.
Write a solution to find the percentage of immediate orders in the first orders of all customers, rounded to 2 decimal places.
The result format is in the following example.
Example 1:
Input: 
Delivery table:
+-------------+-------------+------------+-----------------------------+
| delivery_id | customer_id | order_date | customer_pref_delivery_date |
+-------------+-------------+------------+-----------------------------+
| 1           | 1           | 2019-08-01 | 2019-08-02                  |
| 2           | 2           | 2019-08-02 | 2019-08-02                  |
| 3           | 1           | 2019-08-11 | 2019-08-12                  |
| 4           | 3           | 2019-08-24 | 2019-08-24                  |
| 5           | 3           | 2019-08-21 | 2019-08-22                  |
| 6           | 2           | 2019-08-11 | 2019-08-13                  |
| 7           | 4           | 2019-08-09 | 2019-08-09                  |
+-------------+-------------+------------+-----------------------------+
Output: 
+----------------------+
| immediate_percentage |
+----------------------+
| 50.00                |
+----------------------+
Explanation: 
The customer id 1 has a first order with delivery id 1 and it is scheduled.
The customer id 2 has a first order with delivery id 2 and it is immediate.
The customer id 3 has a first order with delivery id 5 and it is scheduled.
The customer id 4 has a first order with delivery id 7 and it is immediate.
Hence, half the customers have immediate first orders.

Solution:
with firstorder as (select customer_id,min(order_date)as firstorderdate from delivery group by customer_id)
select round(100*sum(case when d.order_date=d.customer_pref_delivery_date then 1 else 0 end)/count(*),2)as immediate_percentage from
delivery d join firstorder f on d.customer_id=f.customer_id and d.order_date=f.firstorderdate

Explanation:
Sure, Mohamed! Here's a clear 4-line explanation:

- The CTE `firstorder` finds each customer's earliest order date.
- The main query focuses only on those first orders by joining on `customer_id` and `order_date`.
- It checks how many first orders were delivered on the customer's preferred delivery date.
- Finally, it calculates the percentage of such "immediate deliveries" and rounds it to two decimals.

8)Game Play Analysis IV

Write a solution to report the fraction of players that logged in again on the day after the day they first logged in, rounded to 2 decimal places. In other words, you need to determine the number of players who logged in on the day immediately following their initial login, and divide it by the number of total players.
The result format is in the following example.

Example 1:
Input: 
Activity table:
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-03-02 | 6            |
| 2         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-02 | 0            |
| 3         | 4         | 2018-07-03 | 5            |
+-----------+-----------+------------+--------------+
Output: 
+-----------+
| fraction  |
+-----------+
| 0.33      |
+-----------+
Explanation: 
Only the player with id 1 logged back in after the first day he had logged in so the answer is 1/3 = 0.33

Solution:
with firstlogin as(select player_id,min(event_date)as firstlogindate from activity group by player_id)
select round(count(f.player_id)*1/(select count(distinct player_id)),2)as fraction from
activity a join firstlogin f on f.player_id=a.player_id and date_add(f.firstlogindate,interval 1 day )=a.event_date

Explanation:
Sure, Mohamed! Here's a clear 4-line explanation:

- The CTE `firstlogin` finds each player's first login date.
- The main query checks if the player logged in again exactly one day after their first login.
- It counts how many players did this and divides by the total number of unique players.
- The result is a fraction (rounded to 2 decimals) showing how many players returned the next day.
