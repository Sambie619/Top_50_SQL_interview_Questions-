1)Employees Whose Manager Left the Company

Find the IDs of the employees whose salary is strictly less than $30000 and whose manager left the company. When a manager leaves the company, their information is deleted from the Employees table, but the reports still have their manager_id set to the manager that left.
Return the result table ordered by employee_id.
The result format is in the following example.

Example 1:

Input:  
Employees table:
+-------------+-----------+------------+--------+
| employee_id | name      | manager_id | salary |
+-------------+-----------+------------+--------+
| 3           | Mila      | 9          | 60301  |
| 12          | Antonella | null       | 31000  |
| 13          | Emery     | null       | 67084  |
| 1           | Kalel     | 11         | 21241  |
| 9           | Mikaela   | null       | 50937  |
| 11          | Joziah    | 6          | 28485  |
+-------------+-----------+------------+--------+
Output: 
+-------------+
| employee_id |
+-------------+
| 11          |
+-------------+

Explanation: 
The employees with a salary less than $30000 are 1 (Kalel) and 11 (Joziah).
Kalel's manager is employee 11, who is still in the company (Joziah).
Joziah's manager is employee 6, who left the company because there is no row for employee 6 as it was deleted.

Solution:
select e.employee_id from employees e left join employees m on e.manager_id=m.employee_id  
where e.manager_id is not null and e.salary<30000 and m.employee_id is null  order by e.employee_id ;

Explanation:
left join employees m on e.manager_id=m.employee_id:
This performs a LEFT JOIN on the employees table with itself. The second instance of the employees table is aliased as m (representing managers)
. The join condition e.manager_id=m.employee_id links each employee to their manager based on the manager_id column
. A LEFT JOIN ensures that all employees from table e are included, even if they don't have a matching manager in table m. 
Where e.manager_id is not null:
This filters the results to include only employees who actually have a manager_id assigned to them, meaning they are not top-level managers.
and e.salary<30000:
This further filters the results to include only employees whose salary is strictly less than 30,000.
and m.employee_id is null:
This is the crucial condition. Because it's a LEFT JOIN, if an e.manager_id does not find a corresponding m.employee_id

2)Exchange Seats

Write a solution to swap the seat id of every two consecutive students. If the number of students is odd, the id of the last student is not swapped.
Return the result table ordered by id in ascending order.
The result format is in the following example.

Example 1:

Input: 
Seat table:
+----+---------+
| id | student |
+----+---------+
| 1  | Abbot   |
| 2  | Doris   |
| 3  | Emerson |
| 4  | Green   |
| 5  | Jeames  |
+----+---------+
Output: 
+----+---------+
| id | student |
+----+---------+
| 1  | Doris   |
| 2  | Abbot   |
| 3  | Green   |
| 4  | Emerson |
| 5  | Jeames  |
+----+---------+

Explanation: 
Note that if the number of students is odd, there is no need to change the last one's seat.

Solution:
select if(id <(select max(id)from seat,if(id%2=0,id-1,id+1),if(id%2=1,id,id-1))as id,student  from seat order by id;

Explanation:
Check if it's the last ID: The outer condition if(id < (select max(id) from seat)) checks if the current row's id is less than the maximum id in the entire table.
Swap for paired students: For all students except the last one, the query checks if their id is even or odd (if(id%2=0,id-1,id+1)). 
If the id is even, it is swapped with the previous one (id-1); if it's odd, it is swapped with the next one (id+1).and the id%2=1 condition checks if the 
last id is odd, this is intended to keep the last student's original id. 
A correct version of the query
Handle the odd-numbered student: The nested if(id%2=1,id,id-1) serves as the ELSE condition for the outer IF. Since this code is only reached when id is not less than the maximum id

