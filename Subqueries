1)Employees Whose Manager Left the Company       
  
Find the IDs of the employees whose salary is strictly less than $30000 and whose manager left the company. When a manager leaves the company, their information is deleted from the Employees table, but the reports still have their manager_id set to the manager that left.
Return the result table ordered by employee_id.
The result format is in the following example.

Example 1:

Input:  
Employees table:
+-------------+-----------+------------+--------+
| employee_id | name      | manager_id | salary |
+-------------+-----------+------------+--------+
| 3           | Mila      | 9          | 60301  |
| 12          | Antonella | null       | 31000  |
| 13          | Emery     | null       | 67084  |
| 1           | Kalel     | 11         | 21241  |
| 9           | Mikaela   | null       | 50937  |
| 11          | Joziah    | 6          | 28485  |
+-------------+-----------+------------+--------+
Output: 
+-------------+
| employee_id |
+-------------+
| 11          |
+-------------+

Explanation: 
The employees with a salary less than $30000 are 1 (Kalel) and 11 (Joziah).
Kalel's manager is employee 11, who is still in the company (Joziah).
Joziah's manager is employee 6, who left the company because there is no row for employee 6 as it was deleted.

Solution:
select e.employee_id from employees e left join employees m on e.manager_id=m.employee_id  
where e.manager_id is not null and e.salary<30000 and m.employee_id is null  order by e.employee_id ;

Explanation:
left join employees m on e.manager_id=m.employee_id:
This performs a LEFT JOIN on the employees table with itself. The second instance of the employees table is aliased as m (representing managers)
. The join condition e.manager_id=m.employee_id links each employee to their manager based on the manager_id column
. A LEFT JOIN ensures that all employees from table e are included, even if they don't have a matching manager in table m. 
Where e.manager_id is not null:
This filters the results to include only employees who actually have a manager_id assigned to them, meaning they are not top-level managers.
and e.salary<30000:
This further filters the results to include only employees whose salary is strictly less than 30,000.
and m.employee_id is null:
This is the crucial condition. Because it's a LEFT JOIN, if an e.manager_id does not find a corresponding m.employee_id

2)Exchange Seats

Write a solution to swap the seat id of every two consecutive students. If the number of students is odd, the id of the last student is not swapped.
Return the result table ordered by id in ascending order.
The result format is in the following example.

Example 1:

Input: 
Seat table:
+----+---------+
| id | student |
+----+---------+
| 1  | Abbot   |
| 2  | Doris   |
| 3  | Emerson |
| 4  | Green   |
| 5  | Jeames  |
+----+---------+
Output: 
+----+---------+
| id | student |
+----+---------+
| 1  | Doris   |
| 2  | Abbot   |
| 3  | Green   |
| 4  | Emerson |
| 5  | Jeames  |
+----+---------+

Explanation: 
Note that if the number of students is odd, there is no need to change the last one's seat.

Solution:
select if(id <(select max(id)from seat,if(id%2=0,id-1,id+1),if(id%2=1,id,id-1))as id,student  from seat order by id;

Explanation:
Check if it's the last ID: The outer condition if(id < (select max(id) from seat)) checks if the current row's id is less than the maximum id in the entire table.
Swap for paired students: For all students except the last one, the query checks if their id is even or odd (if(id%2=0,id-1,id+1)). 
If the id is even, it is swapped with the previous one (id-1); if it's odd, it is swapped with the next one (id+1).and the id%2=1 condition checks if the 
last id is odd, this is intended to keep the last student's original id. 
A correct version of the query
Handle the odd-numbered student: The nested if(id%2=1,id,id-1) serves as the ELSE condition for the outer IF. Since this code is only reached when id is not less than the maximum id

3)Movie Rating

Write a solution to:
Find the name of the user who has rated the greatest number of movies. In case of a tie, return the lexicographically smaller user name.
Find the movie name with the highest average rating in February 2020. In case of a tie, return the lexicographically smaller movie name.
The result format is in the following example.

Example 1:
Input: 
Movies table:
+-------------+--------------+
| movie_id    |  title       |
+-------------+--------------+
| 1           | Avengers     |
| 2           | Frozen 2     |
| 3           | Joker        |
+-------------+--------------+
Users table:
+-------------+--------------+
| user_id     |  name        |
+-------------+--------------+
| 1           | Daniel       |
| 2           | Monica       |
| 3           | Maria        |
| 4           | James        |
+-------------+--------------+
MovieRating table:
+-------------+--------------+--------------+-------------+
| movie_id    | user_id      | rating       | created_at  |
+-------------+--------------+--------------+-------------+
| 1           | 1            | 3            | 2020-01-12  |
| 1           | 2            | 4            | 2020-02-11  |
| 1           | 3            | 2            | 2020-02-12  |
| 1           | 4            | 1            | 2020-01-01  |
| 2           | 1            | 5            | 2020-02-17  | 
| 2           | 2            | 2            | 2020-02-01  | 
| 2           | 3            | 2            | 2020-03-01  |
| 3           | 1            | 3            | 2020-02-22  | 
| 3           | 2            | 4            | 2020-02-25  | 
+-------------+--------------+--------------+-------------+
Output: 
+--------------+
| results      |
+--------------+
| Daniel       |
| Frozen 2     |
+--------------+
Explanation: 
Daniel and Monica have rated 3 movies ("Avengers", "Frozen 2" and "Joker") but Daniel is smaller lexicographically.
Frozen 2 and Joker have a rating average of 3.5 in February but Frozen 2 is smaller lexicographically.

Solution:
(select name as results from users u join movierating mr on u.user_id=mr.user_id group by u.user_id  order by count(*)desc , name asc limit 1)
union all
(select title as results from movies m join movierating mr on m.movie_id=mr.movie_id where mr.created_at between '2020-02-01'and '2020-02-29' 
group by mo.movie_id order by avg(mr.rating)desc, mo.title asc limit 1);

Explanation:
the query will combine the results of two select operations,the first select operation will name by joining users and movierating table for each userid itll count howmany times it appeared
in movierating table
the second select statement will select title by joining movies and movierating table for each movieid and also check if its between the dates of february and will order the results by 
descending of average rating

4)Restaurant Growth

You are the restaurant owner and you want to analyze a possible expansion (there will be at least one customer every day).
Compute the moving average of how much the customer paid in a seven days window (i.e., current day + 6 days before). average_amount should be rounded to two decimal places.
Return the result table ordered by visited_on in ascending order.
The result format is in the following example.

Example 1:
Input: 
Customer table:
+-------------+--------------+--------------+-------------+
| customer_id | name         | visited_on   | amount      |
+-------------+--------------+--------------+-------------+
| 1           | Jhon         | 2019-01-01   | 100         |
| 2           | Daniel       | 2019-01-02   | 110         |
| 3           | Jade         | 2019-01-03   | 120         |
| 4           | Khaled       | 2019-01-04   | 130         |
| 5           | Winston      | 2019-01-05   | 110         | 
| 6           | Elvis        | 2019-01-06   | 140         | 
| 7           | Anna         | 2019-01-07   | 150         |
| 8           | Maria        | 2019-01-08   | 80          |
| 9           | Jaze         | 2019-01-09   | 110         | 
| 1           | Jhon         | 2019-01-10   | 130         | 
| 3           | Jade         | 2019-01-10   | 150         | 
+-------------+--------------+--------------+-------------+
Output: 
+--------------+--------------+----------------+
| visited_on   | amount       | average_amount |
+--------------+--------------+----------------+
| 2019-01-07   | 860          | 122.86         |
| 2019-01-08   | 840          | 120            |
| 2019-01-09   | 840          | 120            |
| 2019-01-10   | 1000         | 142.86         |
+--------------+--------------+----------------+
Explanation: 
1st moving average from 2019-01-01 to 2019-01-07 has an average_amount of (100 + 110 + 120 + 130 + 110 + 140 + 150)/7 = 122.86
2nd moving average from 2019-01-02 to 2019-01-08 has an average_amount of (110 + 120 + 130 + 110 + 140 + 150 + 80)/7 = 120
3rd moving average from 2019-01-03 to 2019-01-09 has an average_amount of (120 + 130 + 110 + 140 + 150 + 80 + 110)/7 = 120
4th moving average from 2019-01-04 to 2019-01-10 has an average_amount of (130 + 110 + 140 + 150 + 80 + 110 + 130 + 150)/7 = 142.86

Solution:
with daysum as(select visited_on,sum(amount)as amount from customer group by visited_on)
select a.visited_on,round(sum(b.amount),2)as amount,round(avg(b.amount),2)as average_amount  from daysum a,daysum b 
where datediff(a.visited_on,b.visited_on)between 0 and 6 group by a.visited_on having count(*)>6  order by a.visited_on;

Explanation:
with daysum as( ... ): This creates a Common Table Expression (CTE) named daysum. It first groups customer visits by visited_on date and calculates the total amount for each day.
from daysum a, daysum b where datediff(a.visited_on, b.visited_on) between 0 and 6: This performs a self-join on the daysum CTE. For each date a.visited_on, it joins with all
dates b.visited_on that are within the previous 6 days, including the current day. This effectively creates a 7-day window.
group by a.visited_on: The results are then grouped by the "current" date (a.visited_on).
having count(*) > 6: This filter ensures that only groups with a full 7 days of data are included in the final output
This eliminates the initial days of data where a full 7-day history isn't available.
select a.visited_on, round(sum(b.amount),2) as amount, round(avg(b.amount),2) as average_amount: For each 7-day window, the query calculates the sum (sum(b.amount)) and average (avg(b.amount)) of the amounts and rounds them to two decimal places.

5)Friend Requests II: Who Has the Most Friends

Write a solution to find the people who have the most friends and the most friends number.
The test cases are generated so that only one person has the most friends.
The result format is in the following example.

Example 1:
Input: 
RequestAccepted table:
+--------------+-------------+-------------+
| requester_id | accepter_id | accept_date |
+--------------+-------------+-------------+      
| 1            | 2           | 2016/06/03  |
| 1            | 3           | 2016/06/08  |
| 2            | 3           | 2016/06/08  |
| 3            | 4           | 2016/06/09  |
+--------------+-------------+-------------+
Output: 
+----+-----+
| id | num |
+----+-----+
| 3  | 3   |
+----+-----+
Explanation: 
The person with id 3 is a friend of people 1, 2, and 4, so he has three friends in total, which is the most number than any others.
Follow up: In the real world, multiple people could have the same most number of friends. Could you find all these people in this case?

Solution:
with cte as(select requester_id as id,accepter_id from requestaccepted union 
select accepter_id as id,requester_id from requestaccepted)
select id,count(distinct accepter_id)as num  from cte group by id order by num desc limit 1; 

Explanation:
the query first constructs a comprehensive list of all friend relationships, ensuring each person involved in a friendship is 
listed as an "id" with their respective "accepter_id" (the friend). Then, it counts the unique friends for each "id" and finally 
retrieves the "id" that has the maximum count of unique friends.

6)Investments in 2016

Write a solution to report the sum of all total investment values in 2016 tiv_2016, for all policyholders who:
have the same tiv_2015 value as one or more other policyholders, and
are not located in the same city as any other policyholder (i.e., the (lat, lon) attribute pairs must be unique).
Round tiv_2016 to two decimal places.
The result format is in the following example.

Example 1:

Input: 
Insurance table:
+-----+----------+----------+-----+-----+
| pid | tiv_2015 | tiv_2016 | lat | lon |
+-----+----------+----------+-----+-----+
| 1   | 10       | 5        | 10  | 10  |
| 2   | 20       | 20       | 20  | 20  |
| 3   | 10       | 30       | 20  | 20  |
| 4   | 10       | 40       | 40  | 40  |
+-----+----------+----------+-----+-----+
Output: 
+----------+
| tiv_2016 |
+----------+
| 45.00    |
+----------+
Explanation: 
The first record in the table, like the last record, meets both of the two criteria.
The tiv_2015 value 10 is the same as the third and fourth records, and its location is unique.
The second record does not meet any of the two criteria. Its tiv_2015 is not like any other policyholders and its location is the same as the third record, which makes the third record fail, too.
So, the result is the sum of tiv_2016 of the first and last record, which is 45.

Solution:
select round(sum(tiv_2016),2)as tiv_2016 from insurance where tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(tiv_2015)>1)
and (lat,lon)in(select lat,lon from insurance group by lat,lon having count(*)=1);

Explanation:
The query sums the tiv_2016 values for insurance policies that meet both conditions: their tiv_2015 value is shared by at least one other policy, 
and their geographical location (latitude and longitude) is unique across all policies. 
The final sum is then rounded to two decimal places and aliased as tiv_2016
