1)The Number of Employees Which Report to Each Employee
 
For this problem, we will consider a manager an employee who has at least 1 other employee reporting to them.
Write a solution to report the ids and the names of all managers, the number of employees who report directly to them, and the average age of the reports rounded to the nearest integer.
Return the result table ordered by employee_id.
The result format is in the following example.

Example 1:

Input: 
Employees table:
+-------------+---------+------------+-----+
| employee_id | name    | reports_to | age |
+-------------+---------+------------+-----+
| 9           | Hercy   | null       | 43  |
| 6           | Alice   | 9          | 41  |
| 4           | Bob     | 9          | 36  |
| 2           | Winston | null       | 37  |
+-------------+---------+------------+-----+
Output: 
+-------------+-------+---------------+-------------+
| employee_id | name  | reports_count | average_age |
+-------------+-------+---------------+-------------+
| 9           | Hercy | 2             | 39          |
+-------------+-------+---------------+-------------+
Explanation: Hercy has 2 people report directly to him, Alice and Bob. Their average age is (41+36)/2 = 38.5, which is 39 after rounding it to the nearest integer.
Example 2:

Input: 
Employees table:
+-------------+---------+------------+-----+ 
| employee_id | name    | reports_to | age |
|-------------|---------|------------|-----|
| 1           | Michael | null       | 45  |
| 2           | Alice   | 1          | 38  |
| 3           | Bob     | 1          | 42  |
| 4           | Charlie | 2          | 34  |
| 5           | David   | 2          | 40  |
| 6           | Eve     | 3          | 37  |
| 7           | Frank   | null       | 50  |
| 8           | Grace   | null       | 48  |
+-------------+---------+------------+-----+ 
Output: 
+-------------+---------+---------------+-------------+
| employee_id | name    | reports_count | average_age |
| ----------- | ------- | ------------- | ----------- |
| 1           | Michael | 2             | 40          |
| 2           | Alice   | 2             | 37          |
| 3           | Bob     | 1             | 37          |
+-------------+---------+---------------+-------------+

Solution:

select managers.employee_id,managers.name,count(employee.employee_id)as reports_count ,avg(employee.age)as average_age from
employees managers join employees employee on employee.reports_to=managers.employee_id group by 1,2 order by managers.employee_id;

Explanation:
This query joins the employees table to itself to find each manager's reports. It then groups employees by their manager to count the 
number of reports and calculate their average age. The final results are displayed in order of the manager's employee ID

2)Primary Department for Each Employee

Employees can belong to multiple departments. When the employee joins other departments, they need to decide which department is their primary department.
Note that when an employee belongs to only one department, their primary column is 'N'.Write a solution to report all the employees with their primary department. 
For employees who belong to one department, report their only department.Return the result table in any order.The result format is in the following example.

Example 1:

Input: 
Employee table:
+-------------+---------------+--------------+
| employee_id | department_id | primary_flag |
+-------------+---------------+--------------+
| 1           | 1             | N            |
| 2           | 1             | Y            |
| 2           | 2             | N            |
| 3           | 3             | N            |
| 4           | 2             | N            |
| 4           | 3             | Y            |
| 4           | 4             | N            |
+-------------+---------------+--------------+
Output: 
+-------------+---------------+
| employee_id | department_id |
+-------------+---------------+
| 1           | 1             |
| 2           | 1             |
| 3           | 3             |
| 4           | 3             |
+-------------+---------------+
Explanation: 
- The Primary department for employee 1 is 1.
- The Primary department for employee 2 is 1.
- The Primary department for employee 3 is 3.
- The Primary department for employee 4 is 3.

Solution:

select employee_id,department_id from employee where primary_flag='Y' union
select employee_id,department_id from employee group by employee_id having count(*)=1;

Explanation:
This SQL query retrieves employee_id and department_id for employees marked as primary (primary_flag='Y'). 
Additionally, it includes employees who appear only once in the employee table, indicating they are associated with a single department. 
The UNION operator combines these two distinct sets of results, ensuring no duplicate employee-department pairs are returned.

3)Triangle Judgement

Report for every three line segments whether they can form a triangle.
Return the result table in any order.

The result format is in the following example.
Example 1:
Input: 
Triangle table:
+----+----+----+
| x  | y  | z  |
+----+----+----+
| 13 | 15 | 30 |
| 10 | 20 | 15 |
+----+----+----+
Output: 
+----+----+----+----------+
| x  | y  | z  | triangle |
+----+----+----+----------+
| 13 | 15 | 30 | No       |
| 10 | 20 | 15 | Yes      |
+----+----+----+----------+

Solution:
select x,y,z,case when (x+y>z) and (x+z>y) and (z+y>x) then 'Yes' else 'No' end as triangle from triangle;

Explanation:
The provided SQL query determines if three given lengths (x, y, z) can form a valid triangle based on the triangle inequality theorem.
This theorem states that the sum of the lengths of any two sides of a triangle must be greater than the length of the third side. 
The CASE statement checks if all three conditions (x+y > z, x+z > y, and z+y > x) are true; if so, it returns 'Yes', otherwise 'No'.

4)Consecutive Numbers

Find all numbers that appear at least three times consecutively.
Return the result table in any order.
The result format is in the following example.

Example 1:

Input: 
Logs table:
+----+-----+
| id | num |
+----+-----+
| 1  | 1   |
| 2  | 1   |
| 3  | 1   |
| 4  | 2   |
| 5  | 1   |
| 6  | 2   |
| 7  | 2   |
+----+-----+
Output: 
+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+
Explanation: 1 is the only number that appears consecutively for at least three times.

Solution:
with cte as(select id,lag(num) over  (order by id)as prev,lead(num) over (order by id)as next from logs)
select distinct(num)as ConsecutiveNums from cte where prev=num and next=num;

Explanation:
The query finds numbers appearing consecutively at least three times. It uses a Common Table Expression (CTE) to create a temporary 
result set where LAG() fetches the previous value and LEAD() fetches the next value for each row. The main query then selects 
distinct numbers where the current row's value equals both the previous and next values, thus identifying triplets. 

5)Product Price at a Given Date

Initially, all products have price 10.
Write a solution to find the prices of all products on the date 2019-08-16.
Return the result table in any order.
The result format is in the following example.

Example 1:
Input: 
Products table:
+------------+-----------+-------------+
| product_id | new_price | change_date |
+------------+-----------+-------------+
| 1          | 20        | 2019-08-14  |
| 2          | 50        | 2019-08-14  |
| 1          | 30        | 2019-08-15  |
| 1          | 35        | 2019-08-16  |
| 2          | 65        | 2019-08-17  |
| 3          | 20        | 2019-08-18  |
+------------+-----------+-------------+
Output: 
+------------+-------+
| product_id | price |
+------------+-------+
| 2          | 50    |
| 1          | 35    |
| 3          | 10    |
+------------+-------+

Solution:
with cte as (select *,rank()over (partition by product_id order by change_date desc)as r 
from products where change_date<="2019-08-16")
select product_id,new_price as price from cte where r=1; union
select product_id,10 as price  from  products where product_id not in (select product_id from cte);

Explanation:
This SQL query retrieves the product_id and price for products, prioritizing the latest price change on or before "2019-08-16".
If a product has no price changes on or before that date, its price defaults to 10. This is achieved by using a CTE to rank price
changes and then unioning with products not found in the CTE.

6)Last Person to Fit in the Bus

There is a queue of people waiting to board a bus. However, the bus has a weight limit of 1000 kilograms, so there may be some people who cannot board.
Write a solution to find the person_name of the last person that can fit on the bus without exceeding the weight limit. The test cases are generated such that the first person does not exceed the weight limit.
Note that only one person can board the bus at any given turn.
The result format is in the following example.

Example 1:
Input: 
Queue table:
+-----------+-------------+--------+------+
| person_id | person_name | weight | turn |
+-----------+-------------+--------+------+
| 5         | Alice       | 250    | 1    |
| 4         | Bob         | 175    | 5    |
| 3         | Alex        | 350    | 2    |
| 6         | John Cena   | 400    | 3    |
| 1         | Winston     | 500    | 6    |
| 2         | Marie       | 200    | 4    |
+-----------+-------------+--------+------+
Output: 
+-------------+
| person_name |
+-------------+
| John Cena   |
+-------------+
Explanation: The folowing table is ordered by the turn for simplicity.
+------+----+-----------+--------+--------------+
| Turn | ID | Name      | Weight | Total Weight |
+------+----+-----------+--------+--------------+
| 1    | 5  | Alice     | 250    | 250          |
| 2    | 3  | Alex      | 350    | 600          |
| 3    | 6  | John Cena | 400    | 1000         | (last person to board)
| 4    | 2  | Marie     | 200    | 1200         | (cannot board)
| 5    | 4  | Bob       | 175    | ___          |
| 6    | 1  | Winston   | 500    | ___          |
+------+----+-----------+--------+--------------+

Solution:
with cte as (select person_name,weight,turn,sum(weight)over( order by turn)as totalweight from queue)
select pperson_name from cte where totalweight<=1000
order by totalweight desc limit 1;

Explanation:
A Common Table Expression (CTE) calculates a running total of weight based on turn order.
It then filters for person_name where this total_weight does not exceed 1000.
Finally, it returns the person_name of the last person added whose total_weight is still within the limit.

7)Count Salary Categories

Write a solution to calculate the number of bank accounts for each salary category. The salary categories are:
"Low Salary": All the salaries strictly less than $20000.
"Average Salary": All the salaries in the inclusive range [$20000, $50000].
"High Salary": All the salaries strictly greater than $50000.
The result table must contain all three categories. If there are no accounts in a category, return 0.
Return the result table in any order.
The result format is in the following example.

Example 1:

Input: 
Accounts table:
+------------+--------+
| account_id | income |
+------------+--------+
| 3          | 108939 |
| 2          | 12747  |
| 8          | 87709  |
| 6          | 91796  |
+------------+--------+
Output: 
+----------------+----------------+
| category       | accounts_count |
+----------------+----------------+
| Low Salary     | 1              |
| Average Salary | 0              |
| High Salary    | 3              |
+----------------+----------------+
Explanation: 
Low Salary: Account 2.
Average Salary: No accounts.
High Salary: Accounts 3, 6, and 8.

Solution:
select 'Low Salary' as category,sum(if(income<20000,1,0))as accounts_count from accounts union 
select 'Average Salary' as category,sum(if(income>=20000 and income<=50000,1,0))as accounts_count from accounts union 
select 'High Salary' as category,sum(if(income>50000,1,0))as accounts_count from accounts order by  accounts_count desc;

Explanation:
The first SELECT counts accounts where the income is strictly less than 20,000, labeling the result as 'Low Salary'.
The second SELECT counts accounts where the income is between 20,000 and 50,000, inclusive, labeling the result as 'Average Salary'.
The third SELECT counts accounts where the income is strictly greater than 50,000, labeling the result as 'High Salary'.
The SUM(IF(condition, 1, 0)) function is used to count the rows that meet each condition.
