1)Fix Names in a Table

Write a solution to fix the names so that only the first character is uppercase and the rest are lowercase.
Return the result table ordered by user_id.
The result format is in the following example. 

Input: 
Users table:
+---------+-------+
| user_id | name  |
+---------+-------+
| 1       | aLice |
| 2       | bOB   |
+---------+-------+
Output: 
+---------+-------+
| user_id | name  |
+---------+-------+
| 1       | Alice |
| 2       | Bob   |
+---------+-------+

Solution:

select user_id,concat(upper(left(name,1)),lower(substring(name,2)))as name from users order by user_id;

Explanation:
The above query will return userid and name where the 1st character of name is made to uppercase and rest substring of name from 2nd character
is in lowercase,and then both are concatenated and called as name ,the rows will be ordered by user_id in ascending order.

2)Patients With a Condition

Write a solution to find the patient_id, patient_name, and conditions of the patients who have Type I Diabetes. Type I Diabetes always starts with DIAB1 prefix.
Return the result table in any order.
The result format is in the following example.

Input: 
Patients table:
+------------+--------------+--------------+
| patient_id | patient_name | conditions   |
+------------+--------------+--------------+
| 1          | Daniel       | YFEV COUGH   |
| 2          | Alice        |              |
| 3          | Bob          | DIAB100 MYOP |
| 4          | George       | ACNE DIAB100 |
| 5          | Alain        | DIAB201      |
+------------+--------------+--------------+
Output: 
+------------+--------------+--------------+
| patient_id | patient_name | conditions   |
+------------+--------------+--------------+
| 3          | Bob          | DIAB100 MYOP |
| 4          | George       | ACNE DIAB100 | 
+------------+--------------+--------------+

Solution:

SELECT * FROM PATIENTS
WHERE conditions regexp '^DIAB1| DIAB1';

Explanation:
This query will select all columns from the table,where the condition either starts from 'DIAB1' or there's ' DIAB1' like where DIAB1 is after
any prefix word followed by space like  ACNE DIAB100
^DIAB1: This part matches strings where DIAB1 appears at the beginning of the conditions string. The ^ is a regular expression anchor that 
signifies the start of the string.
|: This is the OR operator in regular expressions, meaning "match either the pattern before it or the pattern after it.
' DIAB1': This part matches strings where `DIAB1` appears after a space. This is crucial for identifying DIAB1 as a distinct condition when it's
not the first one listed in a space-separated string of conditions. Without the leading space, it could match SADIAB100, which is not a 
distinct "DIAB1" condition.

3)Delete Duplicate Emails

Write a solution to delete all duplicate emails, keeping only one unique email with the smallest id.
For SQL users, please note that you are supposed to write a DELETE statement and not a SELECT one.

Input: 
Person table:
+----+------------------+
| id | email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
| 3  | john@example.com |
+----+------------------+
Output: 
+----+------------------+
| id | email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+

Solution:

delete p1 from person p1 join person p2
on p1.email=p2.email and
p1.id>p2.id;

Explanation:
This query will dlt duplicate rows  from the person table p1 ,with same email by joining the  table p1 with itself(
ie p2 on the condition with same email),and it deletes from p1 where id is greater than p2

4)Second Highest Salary

Write a solution to find the second highest distinct salary from the Employee table. If there is no second highest salary, return null. The result format is in the following example.

Input: 
Employee table:
+----+--------+
| id | salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
Output: 
+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+
Example 2:

Input: 
Employee table:
+----+--------+
| id | salary |
+----+--------+
| 1  | 100    |
+----+--------+
Output: 
+---------------------+
| SecondHighestSalary |
+---------------------+
| null                |
+---------------------+

Solution:

select (select distinct salary from employee order by salary desc limit 1 offset 1) as SecondHighestSalary;

Explanation:
The inner query will select unique salary from the table in descending order by skipping the first one 

5)Group Sold Products By The Date

Write a solution to find for each date the number of different products sold and their names.
The sold products names for each date should be sorted lexicographically.
Return the result table ordered by sell_date.
The result format is in the following example.

Input: 
Activities table:
+------------+------------+
| sell_date  | product     |
+------------+------------+
| 2020-05-30 | Headphone  |
| 2020-06-01 | Pencil     |
| 2020-06-02 | Mask       |
| 2020-05-30 | Basketball |
| 2020-06-01 | Bible      |
| 2020-06-02 | Mask       |
| 2020-05-30 | T-Shirt    |
+------------+------------+
Output: 
+------------+----------+------------------------------+
| sell_date  | num_sold | products                     |
+------------+----------+------------------------------+
| 2020-05-30 | 3        | Basketball,Headphone,T-shirt |
| 2020-06-01 | 2        | Bible,Pencil                 |
| 2020-06-02 | 1        | Mask                         |
+------------+----------+------------------------------+
Explanation: 
For 2020-05-30, Sold items were (Headphone, Basketball, T-shirt), we sort them lexicographically and separate them by a comma.
For 2020-06-01, Sold items were (Pencil, Bible), we sort them lexicographically and separate them by a comma.
For 2020-06-02, the Sold item is (Mask), we just return it.

Solution:

select sell_date,count( distinct product ) as num_sold,group_concat(distinct product order by product asc)as products  from activities group by sell_date;

Explanation:
This query will show the number of products sold on a particular sell_date ,also it shows the products sold seperated by ',' by sorting lexicographically.
The group_concat function will concatenate different rows of a group seperated by ',' into a string 

6)List the Products Ordered in a Period

Write a solution to get the names of products that have at least 100 units ordered in February 2020 and their amount.
Return the result table in any order.
The result format is in the following example.

Input: 
Products table:
+-------------+-----------------------+------------------+
| product_id  | product_name          | product_category |
+-------------+-----------------------+------------------+
| 1           | Leetcode Solutions    | Book             |
| 2           | Jewels of Stringology | Book             |
| 3           | HP                    | Laptop           |
| 4           | Lenovo                | Laptop           |
| 5           | Leetcode Kit          | T-shirt          |
+-------------+-----------------------+------------------+
Orders table:
+--------------+--------------+----------+
| product_id   | order_date   | unit     |
+--------------+--------------+----------+
| 1            | 2020-02-05   | 60       |
| 1            | 2020-02-10   | 70       |
| 2            | 2020-01-18   | 30       |
| 2            | 2020-02-11   | 80       |
| 3            | 2020-02-17   | 2        |
| 3            | 2020-02-24   | 3        |
| 4            | 2020-03-01   | 20       |
| 4            | 2020-03-04   | 30       |
| 4            | 2020-03-04   | 60       |
| 5            | 2020-02-25   | 50       |
| 5            | 2020-02-27   | 50       |
| 5            | 2020-03-01   | 50       |
+--------------+--------------+----------+
Output: 
+--------------------+---------+
| product_name       | unit    |
+--------------------+---------+
| Leetcode Solutions | 130     |
| Leetcode Kit       | 100     |
+--------------------+---------+

Solution:

select p.product_name,sum(o.unit)as unit from products p join orders o on o.product_id=p.product_id where o.order_date between '2020-02-1' and '2020-02-29' group by 
p.product_name having sum(o.unit)>=100;

Explanation:
This query will show the product name and total units sold in the month of february using(where o.order_date between '2020-02-1' and '2020-02-29')
by joining products table with orders table using product_id and itll show that for each product name only if the units sold is greater than or equal to 100

7)Find Users With Valid E-Mails

Write a solution to find the users who have valid emails.
A valid e-mail has a prefix name and a domain where:
The prefix name is a string that may contain letters (upper or lower case), digits, underscore '_', period '.', and/or dash '-'. The prefix name must start with a letter.
The domain is '@leetcode.com'.
Return the result table in any order.
The result format is in the following example.

Input: 
Users table:
+---------+-----------+-------------------------+
| user_id | name      | mail                    |
+---------+-----------+-------------------------+
| 1       | Winston   | winston@leetcode.com    |
| 2       | Jonathan  | jonathanisgreat         |
| 3       | Annabelle | bella-@leetcode.com     |
| 4       | Sally     | sally.come@leetcode.com |
| 5       | Marwan    | quarz#2020@leetcode.com |
| 6       | David     | david69@gmail.com       |
| 7       | Shapiro   | .shapo@leetcode.com     |
+---------+-----------+-------------------------+
Output: 
+---------+-----------+-------------------------+
| user_id | name      | mail                    |
+---------+-----------+-------------------------+
| 1       | Winston   | winston@leetcode.com    |
| 3       | Annabelle | bella-@leetcode.com     |
| 4       | Sally     | sally.come@leetcode.com |
+---------+-----------+-------------------------+
Explanation: 
The mail of user 2 does not have a domain.
The mail of user 5 has the # sign which is not allowed.
The mail of user 6 does not have the leetcode domain.
The mail of user 7 starts with a period.

Solution:
SELECT * FROM Users WHERE mail REGEXP '^[a-zA-Z][a-zA-Z0-9_.-]*@leetcode[.]com$'

Explanation:
Here is a breakdown of the regular expression ^[a-zA-Z][a-zA-Z0-9_.-]*@leetcode[.]com$:
^: This anchors the match to the beginning of the string, ensuring the pattern must start at the very first character of the email address.
[a-zA-Z]: This character class matches any single uppercase or lowercase letter. This means the email prefix must begin with an alphabetic character.
[a-zA-Z0-9_.-]*: This character class matches any single uppercase letter, lowercase letter, digit, underscore (_), period (.), or hyphen (-). The asterisk (*) indicates that this character class can appear zero or more times. This allows for a flexible email prefix containing these characters after the initial letter.
@: This matches the literal "@" symbol, which separates the email prefix from the domain.
leetcode: This matches the literal string "leetcode".
[.]: This matches a literal period (.). The period is enclosed in square brackets to treat it as a literal character, as a period outside of brackets in regex usually acts as a wildcard matching any character.
com: This matches the literal string "com".
$: This anchors the match to the end of the string, ensuring the pattern must end at the very last character of the email address.
